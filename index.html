<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>–°–∏–º—É–ª—è—Ç–æ—Ä —Ö–æ–ª–æ–¥–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/RecordRTC/5.6.2/RecordRTC.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(to bottom, #B0C4DE, #778899);
      font-family: 'Montserrat', sans-serif; 
    }

    .phone {
      width: 200px; 
      height: 400px; 
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
      border: 5px solid #A9A9A9;
      position: relative;
      background-color: transparent;
    }

    .wallpaper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to top, #C0C0C0, #DCDCDC);
      z-index: 1;
    }

    .phone-content { 
      position: relative; 
      z-index: 2; 
      background-color: rgba(255, 255, 255, 0.7);
      width: 100%;
      height: 100%;
      border-radius: 20px; 
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 10px;
      color: black;
      font-size: 7px;
    }

    .time {
      font-weight: bold;
    }

    .caller-info {
      text-align: center;
      color: black;
      margin-top: 15px; 
    }

    .caller-name {
      font-size: 12px;
      font-weight: bold;
    }

    .caller-image {
      width: 40px;
      height: 40px;
      margin: 20px auto 10px auto; 
      border-radius: 50%;
      overflow: hidden;
    }

    .caller-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .call-duration {
      font-size: 9px;
      margin-bottom: 5px; 
    }

    .call-button { 
      position: absolute;
      bottom: 10px; 
      left: 50%;
      transform: translateX(-50%);
      background-color: green; 
      border-radius: 50%;
      width: 35px;
      height: 35px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);
      cursor: pointer;
    }

    .call-button img { 
      width: 20px;
      height: 20px;
    }
    
   .sound-wave-container {
      position: absolute;
      width: 120px; 
      height: 50px; 
      left: 50%;
      transform: translateX(-50%);
      bottom: 60px; 
      overflow: hidden; 
      display: flex;
      align-items: center; 
    }

    .sound-wave {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between; 
    }

    .circle {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background-color: #B0C4DE;
      animation: wave 1.5s infinite ease-in-out; 
    }

    .circle:nth-child(even) {
      animation-delay: .5s; 
    }

    @keyframes wave {
      0%, 100% {
        transform: translateY(0); 
      }
      50% {
        transform: translateY(-20px); 
      }
    }

    .microphone-muted .circle {
      background-color: #D3D3D3; 
      animation-play-state: paused;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <div class="phone">
    <div class="wallpaper"></div> 
    <div class="phone-content">
      <div class="status-bar">
        <span class="time"></span>
        <span class="signal">
          üì∂
        </span>
      </div>

      <div class="caller-info">
        <div class="caller-name">–ö–ª–∏–µ–Ω—Ç</div>
        <div class="call-duration">00:00</div> 
        <div class="caller-image">
          <img id="cyborg-icon" src="cyborg.png" alt="cyborg"> 
        </div> 
      </div>

      <div class="sound-wave-container">
        <div class="sound-wave microphone-muted"> 
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
        </div>
      </div>

      <div class="call-button"> 
        <img src="call_start.png" alt="–ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫" class="microphone-muted">  
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        let tg = window.Telegram.WebApp;
        let isCallActive = false;
        let recorder;
        let audioBlob;
        let isRecording = false;
        let isPlayingResponse = false;
        let silenceTimer;
        let isProcessingRequest = false; 
        let silenceDetectionInterval;
        let currentStream; 
        const urlParams = new URLSearchParams(window.location.search);
        const userId = urlParams.get('user_id');

        const callStartSound = new Audio('start_call.mp3'); 
        const callEndSound = new Audio('end_call.mp3');  

        const SILENCE_THRESHOLD = 1000; 
        let personCharacteristics; 

        tg.ready();

        const callButton = document.querySelector('.call-button');
        const callDuration = document.querySelector('.call-duration');
        const callerImage = document.querySelector('.caller-image');
        const callButtonImg = callButton.querySelector('img');
        const soundWave = document.querySelector('.sound-wave'); 
        let startTime;
        let callTimer;

        tg.expand();

        callButton.addEventListener('click', toggleCall);

        logMessage('App initialized. Is Telegram WebApp: ' + (tg.initData.query_id !== undefined));

        function toggleCall() {
          if (!isCallActive) {
            // –ó–∞–ø—É—Å–∫–∞–µ–º –≥—É–¥–∫–∏
            callStartSound.play();
        
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–ª –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∞—É–¥–∏–æ
            const gender = personCharacteristics ? personCharacteristics.–ø–æ–ª : "–ú—É–∂—Å–∫–æ–π";
        
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º "male" –∏–ª–∏ "female" –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–æ–ª–∞
            const genderString = gender === "–ú—É–∂—Å–∫–æ–π" ? "male" : "female";
            
            // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –∞—É–¥–∏–æ
            const audioNumber = getRandomInt(1, 3);
            const greetingAudio = new Audio(`start_${genderString}_${audioNumber}.mp3`);
        
            // –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –ü–û–°–õ–ï –æ–∫–æ–Ω—á–∞–Ω–∏—è –≥—É–¥–∫–æ–≤
            callStartSound.onended = () => { 
              greetingAudio.play();
            };
        
            // –ó–∞–ø—É—Å–∫–∞–µ–º startCall –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è
            greetingAudio.onended = () => {
              startCall();
              startTime = new Date();
              callTimer = setInterval(updateCallDuration, 1000);
            };
        
          } else {
            endCall();
            clearInterval(callTimer);
            callDuration.textContent = '00:00';
          }
          isCallActive = !isCallActive;
        }

        async function startCall() {
          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –∑–≤–æ–Ω–∫–∞
          document.getElementById('cyborg-icon').style.animation = 'none';
          
          callButton.style.backgroundColor = 'red'; 
          callButtonImg.src = 'call_end.png'; 
          addMessage('–ó–≤–æ–Ω–æ–∫ –Ω–∞—á–∞—Ç', 'system');
          personCharacteristics = await generatePersonCharacteristics();
          console.log("–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:", personCharacteristics); 

          navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
              currentStream = stream;
              initializeRecorder(stream);
              startSilenceDetection(stream);
            })
            .catch(error => {
              console.error('Error accessing the microphone:', error);
              addMessage('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É', 'error');
              endCall();
            });
        }

        function endCall() {
          callButton.style.backgroundColor = 'green';
          callButtonImg.src = 'call_start.png';
          addMessage('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω', 'system');
          callEndSound.play();
          logMessage('Call ended');
          if (tg.initData.query_id !== undefined) {
            tg.sendData(JSON.stringify({ action: 'endCall' }));
          }

          if (silenceTimer) {
            clearTimeout(silenceTimer);
            silenceTimer = null;
          }

          if (silenceDetectionInterval) {
            clearInterval(silenceDetectionInterval);
            silenceDetectionInterval = null;
          }

          deleteConversation();

          if (isRecording) {
            stopRecordingAndSend(personCharacteristics); 
          }
        }

        function resumeListening() {
          if (isCallActive && !isRecording && !isPlayingResponse && !isProcessingRequest) { 
            console.log("–í–æ–∑–æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ");
            initializeRecorder(currentStream);
            startSilenceDetection(currentStream);
          }
        }

        function startRecording() {
          if (isPlayingResponse || isProcessingRequest) { 
            console.log("–í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è –æ—Ç–≤–µ—Ç –∏–ª–∏ –∏–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞, –∑–∞–ø–∏—Å—å –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞.");
            return; 
          }
          isRecording = true;
          recorder.startRecording();
          soundWave.classList.remove('microphone-muted'); 
          console.log("–ó–∞–ø–∏—Å—å –Ω–∞—á–∞—Ç–∞");
        }

        function initializeRecorder(stream) {
          recorder = new RecordRTC(stream, {
            type: 'audio',
            mimeType: 'audio/wav',
            recorderType: RecordRTC.StereoAudioRecorder 
          });
        }

        function stopRecordingAndSend(personCharacteristics) {
          isRecording = false;
          recorder.stopRecording(() => {
            audioBlob = recorder.getBlob();
            sendAudioToServer(audioBlob, personCharacteristics);
          });
          console.log("–ó–∞–ø–∏—Å—å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –æ—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä");
        }


        
        async function sendAudioToServer(audioBlob, personCharacteristics) {
          if (isProcessingRequest) { 
            console.log("–ü—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å –µ—â–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è.");
            return; 
          }

          if (audioBlob.size < 1000) {  
            console.log("–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–π, –ø—Ä–æ–ø—É—Å–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏:", audioBlob.size, "–±–∞–π—Ç");
            resumeListening(); 
            return;
          }

          isProcessingRequest = true; 
          soundWave.classList.add('microphone-muted');

          const formData = new FormData();
          formData.append('audio', audioBlob, 'recording.wav');

          const requestId = Date.now();
          formData.append('requestId', requestId);

          if (personCharacteristics) { 
            formData.append('characteristics', JSON.stringify(personCharacteristics));
          }

          if (userId) {
            formData.append('telegram_user_id', userId);
          } else {
            console.error("–û—à–∏–±–∫–∞: userId –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω");
          }

          try {
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø—É–ª—å—Å–∞—Ü–∏–∏
            document.getElementById('cyborg-icon').style.animation = 'pulse 1s infinite';

            clearInterval(silenceDetectionInterval);
            console.log("–û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...");
            const response = await fetch('http://127.0.0.1:5000/recognize_speech', { 
              method: 'POST',
              body: formData
            });

            console.log("–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞. –°—Ç–∞—Ç—É—Å:", response.status);

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
            }

            const data = await response.json();
            console.log("–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", data);
            if (data.callEnded) {
                endCall();
                return;
            }

            if (data.audio_data) {
              try {
                console.log("–ü–æ–ø—ã—Ç–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ –æ—Ç–≤–µ—Ç–∞...");

                const audio = new Audio();
                audio.src = data.audio_data;

                isPlayingResponse = true; 

                audio.oncanplaythrough = () => {
                  console.log("–ê—É–¥–∏–æ –≥–æ—Ç–æ–≤–æ –∫ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é");
                  audio.playbackRate = 1.25;
                  audio.play().catch(error => {
                    console.error("–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ:", error);
                    isPlayingResponse = false; 
                    resumeListening(); 
                  });
                };

                audio.onended = () => {
                    setTimeout(() => {
                        startSilenceDetection(currentStream); 
                      }, 10); 
                  console.log("–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ –æ—Ç–≤–µ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–æ");
                  isPlayingResponse = false; 
                  resumeListening(); 
                };

                audio.onerror = (e) => {
                  console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—É–¥–∏–æ:", e);
                  isPlayingResponse = false; 
                  resumeListening(); 
                };
              } catch (urlError) {
                console.error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã—Ö:", urlError);
                resumeListening(); 
              }
            } else {
              startSilenceDetection(currentStream);
              console.log("–ê—É–¥–∏–æ –¥–∞–Ω–Ω—ã–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤ –æ—Ç–≤–µ—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞");
              //resumeListening(); 
            }
          } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞—É–¥–∏–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä:', error);
            resumeListening(); 
          } finally {
            isProcessingRequest = false; 
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ 
            document.getElementById('cyborg-icon').style.animation = 'none';
          }
        }        

        function addMessage(message, type) {
          
        }
        
        function logMessage(message) {
          console.log(message);
          if (tg.initData.query_id !== undefined) { 
            tg.sendData(JSON.stringify({action: 'log', message: message}));
          }
        }

        function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        function getRandomElement(array) {
          return array[getRandomInt(0, array.length - 1)];
        }
        
        function generatePersonCharacteristics() {
          const characteristics = {
            "–ø–æ–ª": getRandomElement(["–ú—É–∂—Å–∫–æ–π", "–ñ–µ–Ω—Å–∫–∏–π"]),
            "—Ç–∏–ø_–∫–ª–∏–µ–Ω—Ç–∞": getRandomElement([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]),
            "—É—Ä–æ–≤–µ–Ω—å_–¥–æ—Ö–æ–¥–∞": getRandomElement([
              "–ù–∏–∑–∫–∏–π (–¥–æ 30 000 —Ä—É–±/–º–µ—Å)",
              "–ù–∏–∂–µ —Å—Ä–µ–¥–Ω–µ–≥–æ (30 000 - 50 000 —Ä—É–±/–º–µ—Å)",
              "–°—Ä–µ–¥–Ω–∏–π (50 000 - 100 000 —Ä—É–±/–º–µ—Å)",
              "–í—ã—à–µ —Å—Ä–µ–¥–Ω–µ–≥–æ (100 000 - 200 000 —Ä—É–±/–º–µ—Å)",
              "–í—ã—Å–æ–∫–∏–π (200 000 - 500 000 —Ä—É–±/–º–µ—Å)",
              "–û—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π (–±–æ–ª–µ–µ 500 000 —Ä—É–±/–º–µ—Å)"
            ]),

            "–æ–ø—ã—Ç_–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è": getRandomElement([
              "–ù–æ–≤–∏—á–æ–∫ (–Ω–µ—Ç –æ–ø—ã—Ç–∞)", "–ù–∞—á–∏–Ω–∞—é—â–∏–π (–º–µ–Ω–µ–µ 1 –≥–æ–¥–∞)", "–°—Ä–µ–¥–Ω–∏–π (1-3 –≥–æ–¥–∞)", 
              "–û–ø—ã—Ç–Ω—ã–π (3-5 –ª–µ—Ç)", "–≠–∫—Å–ø–µ—Ä—Ç (–±–æ–ª–µ–µ 5 –ª–µ—Ç)"
            ]),
            "–æ—Ç–Ω–æ—à–µ–Ω–∏–µ_–∫_—Ä–∏—Å–∫—É": getRandomElement([
              "–ö–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π", "–£–º–µ—Ä–µ–Ω–Ω–æ-–∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π", "–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π", "–£–º–µ—Ä–µ–Ω–Ω–æ-–∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π", "–ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π"
            ]),
            "—Ü–µ–ª–∏": getRandomElement([
              "–ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –Ω–∞ –ø–µ–Ω—Å–∏—é", "–ü–æ–∫—É–ø–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏", "–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–µ—Ç–µ–π", 
              "–°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–π –ø–æ–¥—É—à–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏", "–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Å—Å–∏–≤–Ω–æ–≥–æ –¥–æ—Ö–æ–¥–∞", 
              "–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è", "–ü–æ–∫—É–ø–∫–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª—è", "–û—Ç–∫—Ä—ã—Ç–∏–µ –±–∏–∑–Ω–µ—Å–∞"
            ]),
            "—Ç–µ–º–ø–µ—Ä–∞–º–µ–Ω—Ç": getRandomElement([
              "–•–æ–ª–µ—Ä–∏–∫", "–°–∞–Ω–≥–≤–∏–Ω–∏–∫", "–§–ª–µ–≥–º–∞—Ç–∏–∫", "–ú–µ–ª–∞–Ω—Ö–æ–ª–∏–∫"
            ]),
            "–∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è_–ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º–∞—è": getRandomElement([
              "–¢–µ–ª–µ—Ñ–æ–Ω–Ω—ã–µ –∑–≤–æ–Ω–∫–∏", "Email", "WhatsApp", "Telegram", "Viber", "SMS", "–õ–∏—á–Ω—ã–µ –≤—Å—Ç—Ä–µ—á–∏"
            ]),

            "—É—Ä–æ–≤–µ–Ω—å_–∑–Ω–∞–Ω–∏–π_–≤_–æ–±–ª–∞—Å—Ç–∏_—Ñ–∏–Ω–∞–Ω—Å–æ–≤": getRandomElement([
              "–ù–∏–∑–∫–æ–µ (–∑–Ω–∞–µ—Ç —Ç–æ–ª—å–∫–æ –æ –≤–∫–ª–∞–¥–∞—Ö)", "–ë–∞–∑–æ–≤–æ–µ (–∑–Ω–∞–µ—Ç –æ –≤–∫–ª–∞–¥–∞—Ö –∏ –∫—Ä–µ–¥–∏—Ç–∞—Ö)", 
              "–°—Ä–µ–¥–Ω–µ–µ (–∑–Ω–∞–µ—Ç –æ –≤–∫–ª–∞–¥–∞—Ö, –∫—Ä–µ–¥–∏—Ç–∞—Ö, –∞–∫—Ü–∏—è—Ö –∏ –æ–±–ª–∏–≥–∞—Ü–∏—è—Ö)", 
              "–í—ã—Å–æ–∫–æ–µ (—Ä–∞–∑–±–∏—Ä–∞–µ—Ç—Å—è –≤ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤)", 
              "–≠–∫—Å–ø–µ—Ä—Ç–Ω–æ–µ (–≥–ª—É–±–æ–∫–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Ä—ã–Ω–∫–æ–≤)"
            ]),
            "–æ–ø—ã—Ç_—Å_–∫–æ–º–ø–∞–Ω–∏—è–º–∏": getRandomElement([
              "–ù–µ—Ç –æ–ø—ã—Ç–∞", "–ù–µ–≥–∞—Ç–∏–≤–Ω—ã–π –æ–ø—ã—Ç", "–ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –æ–ø—ã—Ç", "–ü–æ–∑–∏—Ç–∏–≤–Ω—ã–π –æ–ø—ã—Ç", 
              "–°–º–µ—à–∞–Ω–Ω—ã–π –æ–ø—ã—Ç (–∏ –ø–æ–∑–∏—Ç–∏–≤–Ω—ã–π, –∏ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–π)"
            ]),
          };

          return characteristics;
        }

        async function deleteConversation() {
          const formData = new FormData();
          formData.append('telegram_user_id', userId); 
          const callDurationSeconds = Math.floor((new Date() - startTime) / 1000); 
          formData.append('call_duration', callDurationSeconds); 
          try {
            const response = await fetch('http://127.0.0.1:5000/delete_conversation', {
              method: 'POST',
              body: formData
            });

            if (response.ok) {
              console.log('Conversation deleted successfully');
            } else {
              console.error('Error deleting conversation:', response.status);
            }
          } catch (error) {
            console.error('Error deleting conversation:', error);
          }
        }

        function startSilenceDetection(stream) {
          const audioContext = new AudioContext();
          const analyser = audioContext.createAnalyser();
          const microphone = audioContext.createMediaStreamSource(stream);
          microphone.connect(analyser);
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);

          let silenceStart = null;
          const SILENCE_DURATION = 1000; 
          const NOISE_THRESHOLD = 10; 

          function checkSilence() {
            if (!isCallActive) {
              console.log("–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Ç–∏—à–∏–Ω—ã");
              clearInterval(silenceDetectionInterval);
              return;
            }

            if (isPlayingResponse) { 
              return;
            }

            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;

            if (average < NOISE_THRESHOLD) {
              if (!silenceStart) {
                silenceStart = Date.now();
              } else if (Date.now() - silenceStart > SILENCE_DURATION && !isPlayingResponse) { 
                if (isRecording) {
                  console.log("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Ç–∏—à–∏–Ω–∞, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø–∏—Å—å");
                  stopRecordingAndSend(personCharacteristics);  
                  silenceStart = null; 
                }
              }
            } else {
              silenceStart = null;
              if (!isRecording && !isPlayingResponse) { 
                console.log("–û–±–Ω–∞—Ä—É–∂–µ–Ω –∑–≤—É–∫, –Ω–∞—á–∏–Ω–∞–µ–º –∑–∞–ø–∏—Å—å");
                startRecording(); 
              }
            }
          }

          silenceDetectionInterval = setInterval(checkSilence, 100); 
        }

        function updateCallDuration() {
          const now = new Date();
          const elapsed = Math.floor((now - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          callDuration.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function updateTime() {
          const now = new Date();
          const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          document.querySelector('.time').textContent = timeString;
        }

        updateTime();
        setInterval(updateTime, 1000);

      });
    </script>
  </div>
</body>
</html>
